import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, filters
from telegram.error import TelegramError

TOKEN = "7912450179:AAF9uY4zH8jD5Olf89knfa31TiTjxzCoZww"

# Configuration - with working test image URLs
CODE_LINKS = {
    "7CODE": {
        "link": "https://t.me/Senpai_Sync_bot",
        "photo": "https://ibb.co/v4nx31jj"  # Working test image
    },
    "VIP123": {
        "link": "https://t.me/Premium_Channel",
        "photo": "https://telegra.ph/file/1ec270f0e8a0dbf5b8a05.jpg"  # Same test image
    }
}

# Track bot messages for deletion
bot_messages = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user = update.effective_user
        args = context.args

        if not args:
            bot_msg = await update.message.reply_text("‚ö†Ô∏è Please use: correct link")
            await track_message(update.message.chat_id, bot_msg.message_id, context)
            return

        code = args[0].upper()
        
        if code in CODE_LINKS:
            data = CODE_LINKS[code]
            keyboard = [[InlineKeyboardButton("üëâ Tap Here", url=data["link"])]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            try:
                # Try sending photo with caption
                bot_msg = await context.bot.send_photo(
                    chat_id=update.effective_chat.id,
                    photo=data["photo"],
                    caption=f"‚úÖ Verified! Welcome, {user.first_name}!‚ùó"
                    
                    " Here is your content.üëá",
                    reply_markup=reply_markup
                )
            except TelegramError as e:
                print(f"Photo send failed: {e}")
                # Fallback to text message
                bot_msg = await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=f"‚úÖ Verified! Welcome, {user.first_name}!",
                    reply_markup=reply_markup
                )
            
            await track_message(update.message.chat_id, bot_msg.message_id, context)
        else:
            bot_msg = await update.message.reply_text("‚ùå Invalid code. No access granted.")
            await track_message(update.message.chat_id, bot_msg.message_id, context)

    except Exception as e:
        print(f"Unexpected error: {e}")
        await update.message.reply_text("üö® Bot error occurred. Please try again.")

async def track_message(chat_id, message_id, context):
    """Track bot's messages for deletion"""
    if chat_id not in bot_messages:
        bot_messages[chat_id] = []
    bot_messages[chat_id].append(message_id)
    asyncio.create_task(delete_message(chat_id, message_id, context))

async def delete_message(chat_id, message_id, context, delay=300):
    """Delete message after delay"""
    await asyncio.sleep(delay)
    try:
        await context.bot.delete_message(chat_id, message_id)
    except TelegramError as e:
        print(f"Delete failed for message {message_id}: {e}")
    finally:
        if chat_id in bot_messages and message_id in bot_messages[chat_id]:
            bot_messages[chat_id].remove(message_id)

def main():
    # Create Application
    application = Application.builder().token(TOKEN).build()
    
    # Add handler
    application.add_handler(
        CommandHandler("start", start, filters=filters.ChatType.PRIVATE)
    )
    
    # Start polling
    print("‚úÖ Bot is running and waiting for messages...")
    application.run_polling()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Bot stopped by user")
    except Exception as e:
        print(f"Fatal error: {e}")

